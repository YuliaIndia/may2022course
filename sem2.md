GIT LEARNING synopsis

## Using Visual studio code

## Seminar1
* GIT BACH - использовать на Windows однократно для первичной авторизации
* выбрать папку, действия в которой будем отслеживать
* *git init* - команда для создания репозитория в выбранной папке
* в результате выполнения *git init* появляется скрытая папка **.git**

1. Создать файл с расширением **.md** (формат marckdown) внутри выбранной папки;
Файл будет помечен как U (untracked);
2. *git add [filename]* - добавить этот файл к списку отслеживаемых;
Файл будет помечен как A (added);
3. *git commit -m"[комментарий к внесенным изменениям]"* - добавить комментарий о сути сделанных на шаге 2 изменений;
Файл будет помечен без буквы;
4. После внесения изменений в файл нажимаем сохранить - Ctrl+S - файл становится помечен как М (Modified);
5. Повторяем шаги 2 и 3, файл снова будет помечен без буквы, а у нас появится новая версия изменений.

## Seminar2

### Создание новой ветки, переход между ветками
* *Git branch [NAME]* - Для создания новой ветки с названием NAME
* *Git checkout [NAME]* - для перехода в ветку NAME
* *Git checkout master* - для перехода в основную ветку master
* *Git branch* - покажет весь список веток и пометит звездочкой и зеленым цветом ту, в которой находимся
* __Новую ветку создавать, находясь в ветке master, т.к. в новую ветку скопируется все то, что есть в ветке, ИЗ КОТОРОЙ мы создаем новую__

### Слияние веток 
* Переходим на основную ветку, В КОТОРУЮ нужно дополнить информацию, как правило - *git checkout master*
* *git merge [NAME]* - слить ne ветку, __в которой находимся__, с веткой NAME, то есть в master добавить информацию из ветки NAME
* при успешном результате есть два варианта бесконфликтного слияния:
1. *fast-forward* - оригинальная ветка догоняет опередившую в случае, если до этого слияния в оригинальной ветке не было коммитов
2. *merge made by 'ort' strategy* - автоматическое слияние, в котором дополнения берутся частями из опережающей ветки и вставляются в нужное место оригинальной ветки. Возможно тогда, когда в опережающей ветке не было удалений прежнего текста оригинальной ветки
* *git log* - показывает, что в логе появился автокоммит по итогу слияния

### Конфликты при слиянии и их разрешение
* Конфликты возникают при наличии противоречащих коммитов в ветках
* При наличии конфликта заголовок файла становится красным и около него появляется восклицательный знак
* *CONFLICT (content) ... Automatic merge failed; fix conflicts and then commit the result.* - так мы видим в логе, что слияние не прошло автоматически, есть ошибки, требующие исправления
* поле с противоречиями выделяется 2мя цветными блоками - *Current Change* и *Incoming Change*
* над этими блоками предлагается 4 варианта решения конфликта:
1. Accept Current Change
2. Accept Incoming Change
3. Accept both
4. Compare changes
* Самый безопасный вариант решения конфликта - 3. оставить оба варианта, а потом уже из слитой основной ветки убрать лишнее

### Удаление веток и исправление текста последнего коммита
* *git branch -d [NAME]* - удалить ветку NAME, когда она уже не нужна
* важно указать строчную -d, а не заглавную -D, т.к. команда delete совершит удаление с автоматической проверкой, все ли данные из ветки перенесены в основную, а Delete совершит удаление в любом случае. Таким образом -d безопаснее, чем -D
* *git commit --ammend -m"исправленный комментарий к предыдущему коммиту"* - команда для замены комментария к предыдущему коммиту на случай, если в нем допущена ошибка

### Дополнительные важные моменты
* Файлы именуем БЕЗ ПРОБЕЛОВ
* буквы заглавные и строчные НЕ одно и то же!
* Если переименовываем файл, в котором работаем, то git сочтет файл со старым названием удаленным, а с новым именем - созданным
* *git status* - покажет нам эти изменения
* чтобы согласовать эти изменения, нужно повторить шаги 2-3 из раздела Семинар1 для файла с новым именем; а для файла со старым именем нужно прописать только шаг 2 из раздела Семинар1, таким образом подтвердив удаление файла с прежним именем

## Seminar3 - работа с Github

### Общая информация
* *Git* — локальная программа на ПК для контроля версий.
* *Github.com* — бесплатный сервис от Microsoft для удаленной работы с репозиторияими
* На Github можно так же редактировать репозиторий и создавать коммиты, как и на Git, но также можно работать совместно над одним репозиторием с разных ПК
* При первом пуше нужно "подружить" локальный git с профилем на Github, нажав в браузере подтверждение
* *Readme.md* - дополнительный файл-визитка, важен для первичного ознакомления с репозиторием
* *.gitignore* - файл для игнорирования картинок и прочих вложений, занимающих много места (их можно прикрепить ссылками)
* К 2м папкам 1 и тот же репозиторий не привязывается

### Команды для работы с Github
* *cd [link]* - change direction - перейти в каталог [link]
* *git clone [link]* - загрузить проект по ссылке с github
* *git remote add origin [link]* - создать репозиторий по ссылке
* *git branch -M [master]* - назначить главной веткой ветку, которую называем master
* *git push origin* - отправить изменения на удаленный репозиторий
* *git push --set-upstream origin [NAME]* - загрузить на github и создать ветвь NAME
* *git push* - загрузить на github
* чтобы добавить исправления в мастер на github, запрашиваем выполнить merge жмем на кнопку "Compare & Pull Request" - там будет выполнен "Merge pull request"
* *git push origin --delete [NAME]* - удалить ветку NAME
* *git pull* - обновить репозиторий у себя с github
